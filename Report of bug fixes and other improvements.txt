!!! Note that all differences to the original code are commented with "Elze" and an optional explanation

***BUG FIXES AND TODOS
1. 	PropLatex --> PropLatexNew) Comment of Ranta "fix negation of in" at lin AKind: "1 \in N" is parsed+linearized as both "1 is a number" and "1 is not a number". New code:
			AKind k x = table {True => top x ++ "\\in" ++ k ; False => top (prefix 3 "\\sim" (constant (top x ++ "\\in" ++ k)))}
	Now it only returns "1 is a number"
2. 	PropLatex --> PropLatexNew) The linearization functions of ModKind and PartPred were wrong and commented out. New code:
			ModKind k m = (m ! True) ++ k ;
			PartPred f y = \\b => (f ! b)  ++ "to" ++ (top y) ;
3.	PropLatex --> PropLatexNew) "\even { 2 }" translates to "2 is even" (PAtom (APred1  Even (IInt 2)) AND "2 is not even" (PNegAtom (APred1 Even (IInt 2))). This happened because of wrong code in the slash 	oper (3rd function). New code: 
			slash : Str -> Bool => Str = \f -> table {True => "\\" + f ; False => top (prefix 3 "\\sim" (constant ("\\" + f)))} ;
		
***LANGUAGE DUTCH ADDED TO THE REPO: the file is called PropDut.gf
		
		
***IMPROVING TRANSLATIONS
1. TransProp.hs) In-situ quantification for quantifiers without a kind is not in the list of conversions, but should be added to avoid bad translations such as "for all x, x is even" (should be "everything is even"). This is how I changed it:
		- In Prop.gf, I added the following functions:
			Everything_IUniv : Ind ;
			Something_IExist : Ind ;
			
		- In PropI.gf, I added the linearizations of these functions:
			Everything_IUniv = {s = everything_NP ; isSymbolic = False} ;
			Something_IExist = {s = something_NP ; isSymbolic = False} ;
			
		- In PropLatex.gf, I added the linearizations of these functions:
			Everything_IUniv = constant (parenth ("\\forall")) ;
			Something_IExist = constant (parenth ("\\exists")) ;
			
		- In TransProp.hs, I added two new cases to the function optimize:
			GPUniv x p | x `elem` (freeVars p) -> inSituWithoutKind GPUniv GEverything_IUniv x $ optimize p
			GPExist x p | x `elem` (freeVars p) -> inSituWithoutKind GPExist GSomething_IExist x $ optimize p
			
		  And I added a new inSitu function called inSituWithoutKind:
			inSituWithoutKind :: (GVar -> GProp -> GProp) -> GInd -> GVar -> GProp -> GProp
			inSituWithoutKind quant qp x b = case b of
			  GPAtom (GAPred1 (GPartPred f y) z)              -> inSituWithoutKind quant qp x (GPAtom (GAPred2 f z y))
			  GPAtom (GAPred1 f y)   | y == vx                -> GPAtom (GAPred1 f qp)
			  GPAtom (GAPred1 f (GIFun1 h y))   | y == vx     -> GPAtom (GAPred1 f (GIFun1 h qp))
			  GPAtom (GAKind  f y)   | y == vx                -> GPAtom (GAKind f qp)
			  GPAtom (GAPredRefl f z)| z == vx                -> GPAtom (GAPredRefl f qp)
			  GPAtom (GAPred2 f z y) | y == vx && notFree x z -> GPAtom (GAPred2 f z qp)
			  GPAtom (GAPred2 f z y) | z == vx && notFree x y -> GPAtom (GAPred2 f qp y)
			  _ -> quant x b
			 where 
			  vx = GIVar x
	
	
****TODOs left:
- Extend lexicon? More-place predicates? Higher-order functions? Iff? Equality function?
- Fix bug:
		>echo|set /p="everything is equal to 0" | stack run trans
		MNone:
		PAtom (APred1 (PartPred Equal (IInt 0)) Everything_IUniv)
		alles is gelijk aan 0
		everything is equal to 0
		kaikki on sama kuin 0
		tout est égal à 0
		alles ist 0 gleich
		\equal to 0 { ( \forall ) }
		tudo é igual a 0
		allting är lika med 0

		MOptimize:
		PAtom (APred1 (PartPred Equal (IInt 0)) Everything_IUniv)
		alles is gelijk aan 0
		everything is equal to 0
		kaikki on sama kuin 0
		tout est égal à 0
		alles ist 0 gleich
		\equal to 0 { ( \forall ) }
		tudo é igual a 0
		allting är lika med 0

		MNormalize:
		trans.EXE: TransProp.hs:(157,12)-(171,17): Non-exhaustive patterns in case